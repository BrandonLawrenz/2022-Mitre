@@ -0,0 +1,4 @@
[flake8]
max-line-length = 88
extend-ignore = E203
exclude = .git,bootloader/lib
 366  .gitignore 
@@ -0,0 +1,366 @@
.DS_Store

.vscode/

**/gcc

socks
*.sock

*.deleteme


# Created by https://www.toptal.com/developers/gitignore/api/python,c,c++,git,pycharm
# Edit at https://www.toptal.com/developers/gitignore?templates=python,c,c++,git,pycharm

### C ###
# Prerequisites
*.d

# Object files
*.o
*.ko
*.obj
*.elf

# Linker output
*.ilk
*.map
*.exp

# Precompiled Headers
*.gch
*.pch

# Libraries
*.lib
*.a
*.la
*.lo

# Shared objects (inc. Windows DLLs)
*.dll
*.so
*.so.*
*.dylib

# Executables
*.exe
*.out
*.app
*.i*86
*.x86_64
*.hex

# Debug files
*.dSYM/
*.su
*.idb
*.pdb

# Kernel Module Compile Results
*.mod*
*.cmd
.tmp_versions/
modules.order
Module.symvers
Mkfile.old
dkms.conf

### C++ ###
# Prerequisites

# Compiled Object files
*.slo

# Precompiled Headers

# Compiled Dynamic libraries

# Fortran module files
*.mod
*.smod

# Compiled Static libraries
*.lai

# Executables

### Git ###
# Created by git for backups. To disable backups in Git:
# $ git config --global mergetool.keepBackup false
*.orig

# Created by git when using merge tools for conflicts
*.BACKUP.*
*.BASE.*
*.LOCAL.*
*.REMOTE.*
*_BACKUP_*.txt
*_BASE_*.txt
*_LOCAL_*.txt
*_REMOTE_*.txt

### PyCharm ###
# Covers JetBrains IDEs: IntelliJ, RubyMine, PhpStorm, AppCode, PyCharm, CLion, Android Studio, WebStorm and Rider
# Reference: https://intellij-support.jetbrains.com/hc/en-us/articles/206544839

# User-specific stuff
.idea/**/workspace.xml
.idea/**/tasks.xml
.idea/**/usage.statistics.xml
.idea/**/dictionaries
.idea/**/shelf

# AWS User-specific
.idea/**/aws.xml

# Generated files
.idea/**/contentModel.xml

# Sensitive or high-churn files
.idea/**/dataSources/
.idea/**/dataSources.ids
.idea/**/dataSources.local.xml
.idea/**/sqlDataSources.xml
.idea/**/dynamic.xml
.idea/**/uiDesigner.xml
.idea/**/dbnavigator.xml

# Gradle
.idea/**/gradle.xml
.idea/**/libraries

# Gradle and Maven with auto-import
# When using Gradle or Maven with auto-import, you should exclude module files,
# since they will be recreated, and may cause churn.  Uncomment if using
# auto-import.
# .idea/artifacts
# .idea/compiler.xml
# .idea/jarRepositories.xml
# .idea/modules.xml
# .idea/*.iml
# .idea/modules
# *.iml
# *.ipr

# CMake
cmake-build-*/

# Mongo Explorer plugin
.idea/**/mongoSettings.xml

# File-based project format
*.iws

# IntelliJ
out/

# mpeltonen/sbt-idea plugin
.idea_modules/

# JIRA plugin
atlassian-ide-plugin.xml

# Cursive Clojure plugin
.idea/replstate.xml

# SonarLint plugin
.idea/sonarlint/

# Crashlytics plugin (for Android Studio and IntelliJ)
com_crashlytics_export_strings.xml
crashlytics.properties
crashlytics-build.properties
fabric.properties

# Editor-based Rest Client
.idea/httpRequests

# Android studio 3.1+ serialized cache file
.idea/caches/build_file_checksums.ser

### PyCharm Patch ###
# Comment Reason: https://github.com/joeblau/gitignore.io/issues/186#issuecomment-215987721

# *.iml
# modules.xml
# .idea/misc.xml
# *.ipr

# Sonarlint plugin
# https://plugins.jetbrains.com/plugin/7973-sonarlint
.idea/**/sonarlint/

# SonarQube Plugin
# https://plugins.jetbrains.com/plugin/7238-sonarqube-community-plugin
.idea/**/sonarIssues.xml

# Markdown Navigator plugin
# https://plugins.jetbrains.com/plugin/7896-markdown-navigator-enhanced
.idea/**/markdown-navigator.xml
.idea/**/markdown-navigator-enh.xml
.idea/**/markdown-navigator/

# Cache file creation bug
# See https://youtrack.jetbrains.com/issue/JBR-2257
.idea/$CACHE_FILE$

# CodeStream plugin
# https://plugins.jetbrains.com/plugin/12206-codestream
.idea/codestream.xml

### Python ###
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
#   For a library or package, you might want to ignore these files since the code is
#   intended to run in multiple environments; otherwise, check them in:
# .python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# poetry
#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control
#poetry.lock

# PEP 582; used by e.g. github.com/David-OConnor/pyflow
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/

# PyCharm
#  JetBrains specific template is maintainted in a separate JetBrains.gitignore that can
#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#  and can be added to the global gitignore or merged into this file.  For a more nuclear
#  option (not recommended) you can uncomment the following to ignore the entire idea folder.
#.idea/

# End of https://www.toptal.com/developers/gitignore/api/python,c,c++,git,pycharm
 3  .gitmodules 
@@ -0,0 +1,3 @@
[submodule "bootloader/lib/tiny-AES-c"]
	path = bootloader/lib/tiny-AES-c
	url = https://github.com/kokke/tiny-AES-c.git
 202  LICENSE.txt 
@@ -0,0 +1,202 @@
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "{}"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright 2022 The MITRE Corporation. All rights reserved
   Approved for Public Release; Distribution Unlimited. Case Number 22-00195-SC1

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
 22  README.md 
@@ -0,0 +1,22 @@
# 2022 MITRE eCTF Challenge: Secure Avionics Flight Firmware Installation Routine (SAFFIRe)
This repository contains an example reference system for MITRE's 2022 Embedded System CTF
(eCTF) - see https://ectf.mitre.org/ for details. This code is incomplete, insecure, and 
does not meet MITRE standards for quality.  This code is being provided for educational 
purposes to serve as a simple example that meets the minimum functional requirements for 
the 2022 eCTF.  Use this code at your own risk!

## Getting Started
Please see the [Getting Started Guide](getting_started.md).

## Project Structure
The example code is structured as follows

* `bootloader/` - Contains everything to build the SAFFIRE bootloader. See [Bootloader README](bootloader/README.md).
* `configuration/` - Directory to hold raw and protected configuration images. The repo comes with an example unprotected configuration binary.
* `dockerfiles/` - Contains all Dockerfiles to build system.
* `firmware/` - Directory to contain raw and protected firmware images. The repo comes with an example unprotected firmware binary.
* `host-tools/` - Contains the host tools.
* `platform/` - Contains everything to run the avionic device.
* `tools/` - Miscellaneous tools to run and interract with SAFFIRe.
* `saffire.cfg` - An example option config file for running SAFFIRe

 119  bootloader/Makefile 
@@ -0,0 +1,119 @@
#  2022 eCTF
#  Bootloader Makefile
#  Kyle Scaplen
#
#  (c) 2022 The MITRE Corporation
#
# This source file is part of an example system for MITRE's 2022 Embedded System CTF (eCTF).
# This code is being provided only for educational purposes for the 2022 MITRE eCTF competition,
# and may not meet MITRE standards for quality. Use this code at your own risk!

# define the part type and base directory - must be defined for makedefs to work
PART=TM4C123GH6PM
CFLAGSgcc=-DTARGET_IS_TM4C123_RB1
ROOT=.

# Uncomment to enable debug symbols
DEBUG=1

# additional base directories
TIVA_ROOT=${ROOT}/lib/tivaware

# add additional directories to search for source files to VPATH
VPATH=${ROOT}/src
VPATH+=${TIVA_ROOT}

# add additional directories to search for header files to IPATH
IPATH=${ROOT}/inc
IPATH+=${TIVA_ROOT}

# Include common makedefs
include ${TIVA_ROOT}/makedefs

# add initial firmware version
CFLAGS+=-DOLDEST_VERSION=${OLDEST_VERSION}

# this rule must come first in `all`
all: ${COMPILER}

# this must be the last build rule of `all`
all: ${COMPILER}/bootloader.axf


################ start crypto example ################
# example AES rules to build in tiny-AES-c: https://github.com/kokke/tiny-AES-c
# make sure submodule has been pulled (run `git submodule update --init`)
# uncomment next line to activate
# EXAMPLE_AES=foo
ifdef EXAMPLE_AES
# path to crypto library
CRYPTOPATH=${ROOT}/lib/tiny-AES-c

# add path to crypto source files to source path
VPATH+=${CRYPTOPATH}

# add crypto library to includes path
IPATH+=${CRYPTOPATH}

# add crypto object file to includes path
# LDFLAGS+=${COMPILER}/aes.o

# add compiler flag to enable example AES code 
CFLAGS+=-DEXAMPLE_AES

# add rule to build crypto library
${COMPILER}/bootloader.axf: ${COMPILER}/aes.o
endif
################ end crypto example ################




# build libraries
${TIVA_ROOT}/driverlib/${COMPILER}/libdriver.a:
	${MAKE} -C ${TIVA_ROOT}/driverlib

tivaware: ${TIVA_ROOT}/driverlib/${COMPILER}/libdriver.a

# clean the libraries
clean_tivaware:
	${MAKE} -C ${TIVA_ROOT}/driverlib clean

# clean all build products
clean: clean_tivaware
	@rm -rf ${COMPILER} ${wildcard *~}

# create the output directory
${COMPILER}:
	@mkdir ${COMPILER}


# check that parameters are defined
check_defined = \
	$(strip $(foreach 1,$1, \
		$(call __check_defined,$1)))
__check_defined = \
	$(if $(value $1),, \
	  $(error Undefined $1))
arg_check:
	$(call check_defined, OLDEST_VERSION)


# for each source file that needs to be compiled besides the file that defines `main`

# Check arguments
${COMPILER}/bootloader.axf: arg_check
${COMPILER}/bootloader.axf: ${COMPILER}/flash.o
${COMPILER}/bootloader.axf: ${COMPILER}/uart.o
${COMPILER}/bootloader.axf: ${COMPILER}/bootloader.o
${COMPILER}/bootloader.axf: ${COMPILER}/startup_${COMPILER}.o
${COMPILER}/bootloader.axf: ${TIVA_ROOT}/driverlib/${COMPILER}/libdriver.a


SCATTERgcc_bootloader=${TIVA_ROOT}/bootloader.ld
ENTRY_bootloader=Bootloader_Startup

# Include the automatically generated dependency files.
ifneq (${MAKECMDGOALS},clean)
-include ${wildcard ${COMPILER}/*.d} __dummy__
endif
 57  bootloader/README.md 
@@ -0,0 +1,57 @@
# SAFFIRe Bootloader
The SAFFIRe bootloader implements the security and functionality of the
device-side part of SAFFIRe and is one of two components your team must
implement (the other being the host tools in `/host-tools/`). The Bootloader
runs on a Tiva C TM4C123GH6PM microcontroller which is emulated using
`qemu-system-arm`.

The Bootloader is split into a few files that may be of interest to you,
although you are free to change any and all files in this directory as long as
functional and build requirements are met:

* `bootloader.c`: Implements the main functionality of the SAFFIRe Bootloader.
  It contains `main()` and handles commands from the host tools to run different
  parts of the avionic update and boot system.
* `uart.{c,h}`: Implements a UART interface to the host, reading and writing raw
  bytes.
* `flash.{c,h}`: Implements a driver for programming the Flash memory.

We have also included the Tivaware driver library for working with the
microcontroller peripherals. You can find Tivaware in `lib/tivaware` and will
find the following files to be of interest:

* `startup_gcc.c`: Implements the system startup code, including initializing
  the stack and jumping to the `main`. There is a good chance that you will not
  need to change `startup_gcc.c`, but some advanced designs may require it.
* `bootloader.ld`: The linker script to set up memory regions. There is a good
  chance that you will not need to change `bootloader.ld`, but some advanced
  designs may require it.
* `makedefs`: The common definitions included when compiling the Tivaware
  library and your SAFFIRe bootloader. If you want to specific optimizations and
  compiler options to both Tivaware and the bootloader, add/change them here.
  Otherwise, those options can be added to `bootloader/Makefile`.

## On Adding Crypto
To aid with development, we have included Makefile rules and example code for using
[tiny-AES-c](https://github.com/kokke/tiny-AES-c) (see line 46 of the Makefile and
lines 21 and 207 of bootloader.c). You are free to use the library for your crypto
or simply use build process as a template for another crypto library of your choice.

If you choose to use a different crypto library, we recommend using the following
steps to integrate it into your system. **NOTE: All added libraries must compile
from the `all` rule of `bootloader/Makefile` to follow the functional requirements.**
1. Find a crypto library suitable for your embedded system. **Make sure it does not
   require any system calls or dynamic memory allocation (i.e. malloc), as the
   bootloader runs on bare metal without an operating system**
2. Add the library to the `bootloader/` directory either as a submodule in git or
   as a copy of the library source code
3. Run the included tests of the library to verify it works properly on your machine
   before you integrate it with your code
4. Add the directory path to the list of include paths (`IPATH+=/path/to/crypto`)
   in `bootloader/Makefile`
5. Add the directory path to the list of source files (`VPATH+=/path/to/crypto`)
   in `bootloader/Makefile`
6. Add each object file you wish to link to the LDFLAGS list
   (`LDFLAGS+=${COMPILER}/source_file_name.o`) in `bootloader/Makefile`
7. Add each object file you wish to link to the `all` rule 
   (`all: ${COMPILER}/source_file_name.o`) in `bootloader/Makefile`
 60  bootloader/inc/flash.h 
@@ -0,0 +1,60 @@
/**
 * @file flash.h
 * @author Kyle Scaplen
 * @brief Bootloader flash memory interface implementation.
 * @date 2022
 * 
 * This source file is part of an example system for MITRE's 2022 Embedded System CTF (eCTF).
 * This code is being provided only for educational purposes for the 2022 MITRE eCTF competition,
 * and may not meet MITRE standards for quality. Use this code at your own risk!
 * 
 * @copyright Copyright (c) 2022 The MITRE Corporation
 */

#ifndef FLASH_H
#define FLASH_H

#include <stdint.h>

// Flash properties
#define FLASH_START        ((uint32_t)0x00000000)
#define FLASH_PAGE_SIZE    ((uint32_t)0x00000400)
#define FLASH_END          ((uint32_t)0x00040000)

// Function Prototypes

/**
 * @brief Erases a block of flash.
 * 
 * @param addr is the starting address of the block of flash to erase.
 * @return 0 on success, or -1 if an invalid block address was specified or the 
 * block is write-protected.
 */
int32_t flash_erase_page(uint32_t addr);

/**
 * @brief Writes a word to flash.
 * 
 * This function writes a single word to flash memory. The flash address must
 * be a multiple of 4.
 * 
 * @param data is the value to write.
 * @param addr is the location to write to.
 * @return 0 on success, or -1 if an error occurs.
 */
int32_t flash_write_word(uint32_t data, uint32_t addr);

/**
 * @brief Writes data to flash.
 * 
 * This function writes a sequence of words to flash memory. Because the flash 
 * is written one word at a time, the starting address must be a multiple of 4.
 * 
 * @param data is a pointer to the data to be written.
 * @param addr is the starting address in flash to be written to.
 * @param count is the number of words to be written.
 * @return 0 on success, or -1 if an error occurs.
 */
int32_t flash_write(uint32_t *data, uint32_t addr, uint32_t count);

#endif // FLASH_H 
 92  bootloader/inc/uart.h 
@@ -0,0 +1,92 @@
/**
 * @file uart.h
 * @author Kyle Scaplen
 * @brief Bootloader UART interface implementation.
 * @date 2022
 * 
 * This source file is part of an example system for MITRE's 2022 Embedded System CTF (eCTF).
 * This code is being provided only for educational purposes for the 2022 MITRE eCTF competition,
 * and may not meet MITRE standards for quality. Use this code at your own risk!
 * 
 * @copyright Copyright (c) 2022 The MITRE Corporation
 */

#ifndef UART_H
#define UART_H

#include <stdint.h>
#include <stdbool.h>

#include "inc/hw_memmap.h"

#define HOST_UART ((uint32_t)UART0_BASE)

/**
 * @brief Initialize the UART interfaces.
 * 
 * UART 0 is used to communicate with the host device to receive updates,
 * retrieve configuration data, send readback information, and boot the device.
 */
void uart_init(void);


/**
 * @brief Check if there are characters available on a UART interface.
 * 
 * @param uart is the base address of the UART port.
 * @return true if there is data available.
 * @return false if there is no data available.
 */
bool uart_avail(uint32_t uart);


/**
 * @brief Read a byte from a UART interface.
 * 
 * @param uart is the base address of the UART port to read from.
 * @return the character read from the interface.
 */
int32_t uart_readb(uint32_t uart);


/**
 * @brief Read a sequence of bytes from a UART interface.
 * 
 * @param uart is the base address of the UART port to read from.
 * @param buf is a pointer to the destination for the received data.
 * @param n is the number of bytes to read.
 * @return the number of bytes read from the UART interface.
 */
uint32_t uart_read(uint32_t uart, uint8_t *buf, uint32_t n);


/**
 * @brief Read a line (terminated with '\n') from a UART interface.
 * 
 * @param uart is the base address of the UART port to read from.
 * @param buf is a pointer to the destination for the received data.
 * @return the number of bytes read from the UART interface.
 */
uint32_t uart_readline(uint32_t uart, uint8_t *buf);


/**
 * @brief Write a byte to a UART interface.
 * 
 * @param uart is the base address of the UART port to write to.
 * @param data is the byte value to write.
 */
void uart_writeb(uint32_t uart, uint8_t data);


/**
 * @brief Write a sequence of bytes to a UART interface.
 * 
 * @param uart is the base address of the UART port to write to.
 * @param buf is a pointer to the data to send.
 * @param len is the number of bytes to send.
 * @return the number of bytes written.
 */
uint32_t uart_write(uint32_t uart, uint8_t *buf, uint32_t len);

#endif // UART_H
 339  bootloader/src/bootloader.c 
@@ -0,0 +1,339 @@
/**
 * @file bootloader.c
 * @author Kyle Scaplen
 * @brief Bootloader implementation
 * @date 2022
 * 
 * This source file is part of an example system for MITRE's 2022 Embedded System CTF (eCTF).
 * This code is being provided only for educational purposes for the 2022 MITRE eCTF competition,
 * and may not meet MITRE standards for quality. Use this code at your own risk!
 * 
 * @copyright Copyright (c) 2022 The MITRE Corporation
 */

#include <stdint.h>
#include <stdbool.h>

#include "driverlib/interrupt.h"

#include "flash.h"
#include "uart.h"

// this will run if EXAMPLE_AES is defined in the Makefile (see line 54)
#ifdef EXAMPLE_AES
#include "aes.h"
#endif


// Storage layout

/*
 * Firmware:
 *      Version: 0x0002B400 : 0x0002B404 (4B)
 *      Size:    0x0002B404 : 0x0002B408 (4B)
 *      Msg:     0x0002B408 : 0x0002BC00 (~2KB = 1KB + 1B + pad)
 *      Fw:      0x0002BC00 : 0x0002FC00 (16KB)
 * Configuration:
 *      Size:    0x0002FC00 : 0x0003000 (1KB = 4B + pad)
 *      Cfg:     0x00030000 : 0x0004000 (64KB)
 */
#define FIRMWARE_METADATA_PTR      ((uint32_t)(FLASH_START + 0x0002B400))
#define FIRMWARE_SIZE_PTR          ((uint32_t)(FIRMWARE_METADATA_PTR + 0))
#define FIRMWARE_VERSION_PTR       ((uint32_t)(FIRMWARE_METADATA_PTR + 4))
#define FIRMWARE_RELEASE_MSG_PTR   ((uint32_t)(FIRMWARE_METADATA_PTR + 8))
#define FIRMWARE_RELEASE_MSG_PTR2  ((uint32_t)(FIRMWARE_METADATA_PTR + FLASH_PAGE_SIZE))

#define FIRMWARE_STORAGE_PTR       ((uint32_t)(FIRMWARE_METADATA_PTR + (FLASH_PAGE_SIZE*2)))
#define FIRMWARE_BOOT_PTR          ((uint32_t)0x20004000)

#define CONFIGURATION_METADATA_PTR ((uint32_t)(FIRMWARE_STORAGE_PTR + (FLASH_PAGE_SIZE*16)))
#define CONFIGURATION_SIZE_PTR     ((uint32_t)(CONFIGURATION_METADATA_PTR + 0))

#define CONFIGURATION_STORAGE_PTR  ((uint32_t)(CONFIGURATION_METADATA_PTR + FLASH_PAGE_SIZE))




// Firmware update constants
#define FRAME_OK 0x00
#define FRAME_BAD 0x01


/**
 * @brief Boot the firmware.
 */
void handle_boot(void)
{
    uint32_t size;
    uint32_t i = 0;
    uint8_t *rel_msg;

    // Acknowledge the host
    uart_writeb(HOST_UART, 'B');

    // Find the metadata
    size = *((uint32_t *)FIRMWARE_SIZE_PTR);

    // Copy the firmware into the Boot RAM section
    for (i = 0; i < size; i++) {
        *((uint8_t *)(FIRMWARE_BOOT_PTR + i)) = *((uint8_t *)(FIRMWARE_STORAGE_PTR + i));
    }

    uart_writeb(HOST_UART, 'M');

    // Print the release message
    rel_msg = (uint8_t *)FIRMWARE_RELEASE_MSG_PTR;
    while (*rel_msg != 0) {
        uart_writeb(HOST_UART, *rel_msg);
        rel_msg++;
    }
    uart_writeb(HOST_UART, '\0');

    // Execute the firmware
    void (*firmware)(void) = (void (*)(void))(FIRMWARE_BOOT_PTR + 1);
    firmware();
}


/**
 * @brief Send the firmware data over the host interface.
 */
void handle_readback(void)
{
    uint8_t region;
    uint8_t *address;
    uint32_t size = 0;

    // Acknowledge the host
    uart_writeb(HOST_UART, 'R');

    // Receive region identifier
    region = (uint32_t)uart_readb(HOST_UART);

    if (region == 'F') {
        // Set the base address for the readback
        address = (uint8_t *)FIRMWARE_STORAGE_PTR;
        // Acknowledge the host
        uart_writeb(HOST_UART, 'F');
    } else if (region == 'C') {
        // Set the base address for the readback
        address = (uint8_t *)CONFIGURATION_STORAGE_PTR;
        // Acknowledge the hose
        uart_writeb(HOST_UART, 'C');
    } else {
        return;
    }

    // Receive the size to send back to the host
    size = ((uint32_t)uart_readb(HOST_UART)) << 24;
    size |= ((uint32_t)uart_readb(HOST_UART)) << 16;
    size |= ((uint32_t)uart_readb(HOST_UART)) << 8;
    size |= (uint32_t)uart_readb(HOST_UART);

    // Read out the memory
    uart_write(HOST_UART, address, size);
}


/**
 * @brief Read data from a UART interface and program to flash memory.
 * 
 * @param interface is the base address of the UART interface to read from.
 * @param dst is the starting page address to store the data.
 * @param size is the number of bytes to load.
 */
void load_data(uint32_t interface, uint32_t dst, uint32_t size)
{
    int i;
    uint32_t frame_size;
    uint8_t page_buffer[FLASH_PAGE_SIZE];

    while(size > 0) {
        // calculate frame size
        frame_size = size > FLASH_PAGE_SIZE ? FLASH_PAGE_SIZE : size;
        // read frame into buffer
        uart_read(HOST_UART, page_buffer, frame_size);
        // pad buffer if frame is smaller than the page
        for(i = frame_size; i < FLASH_PAGE_SIZE; i++) {
            page_buffer[i] = 0xFF;
        }
        // clear flash page
        flash_erase_page(dst);
        // write flash page
        flash_write((uint32_t *)page_buffer, dst, FLASH_PAGE_SIZE >> 2);
        // next page and decrease size
        dst += FLASH_PAGE_SIZE;
        size -= frame_size;
        // send frame ok
        uart_writeb(HOST_UART, FRAME_OK);
    }
}

/**
 * @brief Update the firmware.
 */
void handle_update(void)
{
    // metadata
    uint32_t current_version;
    uint32_t version = 0;
    uint32_t size = 0;
    uint32_t rel_msg_size = 0;
    uint8_t rel_msg[1025]; // 1024 + terminator

    // Acknowledge the host
    uart_writeb(HOST_UART, 'U');

    // Receive version
    version = ((uint32_t)uart_readb(HOST_UART)) << 8;
    version |= (uint32_t)uart_readb(HOST_UART);

    // Receive size
    size = ((uint32_t)uart_readb(HOST_UART)) << 24;
    size |= ((uint32_t)uart_readb(HOST_UART)) << 16;
    size |= ((uint32_t)uart_readb(HOST_UART)) << 8;
    size |= (uint32_t)uart_readb(HOST_UART);

    // Receive release message
    rel_msg_size = uart_readline(HOST_UART, rel_msg) + 1; // Include terminator

    // Check the version
    current_version = *((uint32_t *)FIRMWARE_VERSION_PTR);
    if (current_version == 0xFFFFFFFF) {
        current_version = (uint32_t)OLDEST_VERSION;
    }

    if (version < current_version) {
        // Version is not acceptable
        uart_writeb(HOST_UART, FRAME_BAD);
        return;
    }

    // Clear firmware metadata
    flash_erase_page(FIRMWARE_METADATA_PTR);

    // Only save new version if it is not 0
    if (version != 0) {
        flash_write_word(version, FIRMWARE_VERSION_PTR);
    } else {
        flash_write_word(current_version, FIRMWARE_VERSION_PTR);
    }

    // Save size
    flash_write_word(size, FIRMWARE_SIZE_PTR);

    // Write release message
    uint8_t *rel_msg_read_ptr = rel_msg;
    uint32_t rel_msg_write_ptr = FIRMWARE_RELEASE_MSG_PTR;
    uint32_t rem_bytes = rel_msg_size;

    // If release message goes outside of the first page, write the first full page
    if (rel_msg_size > (FLASH_PAGE_SIZE-8)) {

        // Write first page
        flash_write((uint32_t *)rel_msg, FIRMWARE_RELEASE_MSG_PTR, (FLASH_PAGE_SIZE-8) >> 2); // This is always a multiple of 4

        // Set up second page
        rem_bytes = rel_msg_size - (FLASH_PAGE_SIZE-8);
        rel_msg_read_ptr = rel_msg + (FLASH_PAGE_SIZE-8);
        rel_msg_write_ptr = FIRMWARE_RELEASE_MSG_PTR2;
        flash_erase_page(rel_msg_write_ptr);
    }

    // Program last or only page of release message
    if (rem_bytes % 4 != 0) {
        rem_bytes += 4 - (rem_bytes % 4); // Account for partial word
    }
    flash_write((uint32_t *)rel_msg_read_ptr, rel_msg_write_ptr, rem_bytes >> 2);

    // Acknowledge
    uart_writeb(HOST_UART, FRAME_OK);

    // Retrieve firmware
    load_data(HOST_UART, FIRMWARE_STORAGE_PTR, size);
}


/**
 * @brief Load configuration data.
 */
void handle_configure(void)
{
    uint32_t size = 0;

    // Acknowledge the host
    uart_writeb(HOST_UART, 'C');

    // Receive size
    size = (((uint32_t)uart_readb(HOST_UART)) << 24);
    size |= (((uint32_t)uart_readb(HOST_UART)) << 16);
    size |= (((uint32_t)uart_readb(HOST_UART)) << 8);
    size |= ((uint32_t)uart_readb(HOST_UART));

    flash_erase_page(CONFIGURATION_METADATA_PTR);
    flash_write_word(size, CONFIGURATION_SIZE_PTR);

    uart_writeb(HOST_UART, FRAME_OK);

    // Retrieve configuration
    load_data(HOST_UART, CONFIGURATION_STORAGE_PTR, size);
}


/**
 * @brief Host interface polling loop to receive configure, update, readback,
 * and boot commands.
 * 
 * @return int
 */
int main(void) {

    uint8_t cmd = 0;

#ifdef EXAMPLE_AES
    // -------------------------------------------------------------------------
    // example encryption using tiny-AES-c
    // -------------------------------------------------------------------------
    struct AES_ctx ctx;
    uint8_t key[16] = { 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 
                        0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf };
    uint8_t plaintext[16] = "0123456789abcdef";

    // initialize context
    AES_init_ctx(&ctx, key);

    // encrypt buffer (encryption happens in place)
    AES_ECB_encrypt(&ctx, plaintext);

    // decrypt buffer (decryption happens in place)
    AES_ECB_decrypt(&ctx, plaintext);
    // -------------------------------------------------------------------------
    // end example
    // -------------------------------------------------------------------------
#endif

    // Initialize IO components
    uart_init();

    // Handle host commands
    while (1) {
        cmd = uart_readb(HOST_UART);

        switch (cmd) {
        case 'C':
            handle_configure();
            break;
        case 'U':
            handle_update();
            break;
        case 'R':
            handle_readback();
            break;
        case 'B':
            handle_boot();
            break;
        default:
            break;
        }
    }
}
 112  bootloader/src/flash.c 
@@ -0,0 +1,112 @@
/**
 * @file flash.h
 * @author Kyle Scaplen
 * @brief Bootloader flash memory interface implementation.
 * @date 2022
 * 
 * This source file is part of an example system for MITRE's 2022 Embedded System CTF (eCTF).
 * This code is being provided only for educational purposes for the 2022 MITRE eCTF competition,
 * and may not meet MITRE standards for quality. Use this code at your own risk!
 * 
 * @copyright Copyright (c) 2022 The MITRE Corporation
 */

#include <stdbool.h>
#include <stdint.h>

#include "driverlib/flash.h"
#include "inc/hw_flash.h"
#include "inc/hw_types.h"

#include "flash.h"

/**
 * @brief Erases a block of flash.
 * 
 * @param addr is the starting address of the block of flash to erase.
 * @return 0 on success, or -1 if an invalid block address was specified or the 
 * block is write-protected.
 */
int32_t flash_erase_page(uint32_t addr)
{
    // Erase page containing this address
    return FlashErase(addr & ~(FLASH_PAGE_SIZE - 1));
} 

/**
 * @brief Writes a word to flash.
 * 
 * This function writes a single word to flash memory. The flash address must
 * be a multiple of 4.
 * 
 * @param data is the value to write.
 * @param addr is the location to write to.
 * @return 0 on success, or -1 if an error occurs.
 */
int32_t flash_write_word(uint32_t data, uint32_t addr)
{
    // check address is a multiple of 4
    if ((addr & 0x3) != 0) {
        return -1;
    }

    // Clear the flash access and error interrupts.
    HWREG(FLASH_FCMISC) = (FLASH_FCMISC_AMISC | FLASH_FCMISC_VOLTMISC | FLASH_FCMISC_INVDMISC | FLASH_FCMISC_PROGMISC);

    // Set the address
    HWREG(FLASH_FMA) = addr & FLASH_FMA_OFFSET_M;

    // Set the data
    HWREG(FLASH_FMD) = data;

    // Set the memory write key and the write bit
    HWREG(FLASH_FMC) = FLASH_FMC_WRKEY | FLASH_FMC_WRITE;

    // Wait for the write bit to get cleared
    while(HWREG(FLASH_FMC) & FLASH_FMC_WRITE);

    // Return an error if an access violation occurred.
    if(HWREG(FLASH_FCRIS) & (FLASH_FCRIS_ARIS | FLASH_FCRIS_VOLTRIS | FLASH_FCRIS_INVDRIS | FLASH_FCRIS_PROGRIS)) {
        return -1;
    }

    // Success
    return 0;
}


/**
 * @brief Writes data to flash.
 * 
 * This function writes a sequence of words to flash memory. Because the flash 
 * is written one word at a time, the starting address must be a multiple of 4.
 * 
 * @param data is a pointer to the data to be written.
 * @param addr is the starting address in flash to be written to.
 * @param count is the number of words to be written.
 * @return 0 on success, or -1 if an error occurs.
 */
int32_t flash_write(uint32_t *data, uint32_t addr, uint32_t count)
{
    int i;
    int status;

    // check address and count are multiples of 4
    if ((addr & 0x3) != 0) {
        return -1;
    }

    // Loop over the words to be programmed.
    for (i = 0; i < count; i++) {
        status = flash_write_word(data[i], addr);

        if (status == -1) {
            return -1;
        }

        addr += 4;
    }

    // Success
    return(0);
}
 171  bootloader/src/uart.c 
@@ -0,0 +1,171 @@
/**
 * @file uart.c
 * @author Kyle Scaplen
 * @brief Bootloader UART interface implementation.
 * @date 2022
 * 
 * This source file is part of an example system for MITRE's 2022 Embedded System CTF (eCTF).
 * This code is being provided only for educational purposes for the 2022 MITRE eCTF competition,
 * and may not meet MITRE standards for quality. Use this code at your own risk!
 * 
 * @copyright Copyright (c) 2022 The MITRE Corporation
 */

#include <stdint.h>
#include <stdbool.h>
#include <string.h>

#include "inc/hw_memmap.h"
#include "inc/hw_uart.h"
#include "inc/hw_types.h"
#include "driverlib/fpu.h"
#include "driverlib/gpio.h"
#include "driverlib/pin_map.h"
#include "driverlib/sysctl.h"
#include "driverlib/uart.h"

#include "uart.h"


/**
 * @brief Initialize the UART interfaces.
 * 
 * UART 0 is used to communicate with the host device to receive updates,
 * retrieve configuration data, send readback information, and boot the device.
 */
void uart_init(void)
{
    // Configure the UART peripherals used in this example
    // RCGC   Run Mode Clock Gating
    SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0);  // UART 0 for host interface
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);  // UART 0 is on GPIO Port A
    // HBCTL  High-performance Bus Control
    // PCTL   Port Control
    GPIOPinConfigure(GPIO_PA0_U0RX);
    GPIOPinConfigure(GPIO_PA1_U0TX);
    // DIR    Direction
    // AFSEL  Alternate Function Select 
    // DR2R   2-mA Drive Select
    // DR4R   4-mA Drive Select
    // DR8R   8-mA Drive Select
    // SLR    Slew Rate Control Select
    // ODR    Open Drain Select
    // PUR    Pull-Up Select
    // PDR    Pull-Down Select
    // DEN    Digital Enable
    // AMSEL  Analog Mode Select
    GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1);

    // Configure the UARTs for 115,200, 8-N-1 operation.
    UARTConfigSetExpClk(UART0_BASE, SysCtlClockGet(), 115200,
                        (UART_CONFIG_WLEN_8 | UART_CONFIG_STOP_ONE | UART_CONFIG_PAR_NONE));
}


/**
 * @brief Check if there are characters available on a UART interface.
 * 
 * @param uart is the base address of the UART port.
 * @return true if there is data available.
 * @return false if there is no data available.
 */
bool uart_avail(uint32_t interface)
{
    return UARTCharsAvail(interface);
}


/**
 * @brief Read a byte from a UART interface.
 * 
 * @param uart is the base address of the UART port to read from.
 * @return the character read from the interface.
 */
int32_t uart_readb(uint32_t uart)
{
    return UARTCharGet(uart);
}


/**
 * @brief Read a sequence of bytes from a UART interface.
 * 
 * @param uart is the base address of the UART port to read from.
 * @param buf is a pointer to the destination for the received data.
 * @param n is the number of bytes to read.
 * @return the number of bytes read from the UART interface.
 */
uint32_t uart_read(uint32_t uart, uint8_t *buf, uint32_t n)
{
    uint32_t read;

    for (read = 0; read < n; read++) {
        buf[read] = (uint8_t)uart_readb(uart);

        // give QEMU some time to queue the next byte if it's there
        for (int i = 0; i < 100000; i++) *buf = *buf;
    }
    return read;
}


/**
 * @brief Read a line (terminated with '\n') from a UART interface.
 * 
 * @param uart is the base address of the UART port to read from.
 * @param buf is a pointer to the destination for the received data.
 * @return the number of bytes read from the UART interface.
 */
uint32_t uart_readline(uint32_t uart, uint8_t *buf)
{
    uint32_t read = 0;
    uint8_t c;

    do {
        c = (uint8_t)uart_readb(uart);

        if ((c != '\r') && (c != '\n') && (c != '\0')) {
            buf[read] = c;
            read++;
        }

        // give QEMU some time to queue the next byte if it's there
        for (int i = 0; i < 100000; i++) *buf = *buf;
    } while ((c != '\n') && (c != '\0'));

    buf[read] = '\0';

    return read;
}


/**
 * @brief Write a byte to a UART interface.
 * 
 * @param uart is the base address of the UART port to write to.
 * @param data is the byte value to write.
 */
void uart_writeb(uint32_t uart, uint8_t data)
{
    UARTCharPut(uart, data);
}


/**
 * @brief Write a sequence of bytes to a UART interface.
 * 
 * @param uart is the base address of the UART port to write to.
 * @param buf is a pointer to the data to send.
 * @param len is the number of bytes to send.
 * @return the number of bytes written.
 */
uint32_t uart_write(uint32_t uart, uint8_t *buf, uint32_t len)
{
    uint32_t i;

    for (i = 0; i < len; i++) {
        uart_writeb(uart, buf[i]);
    }

    return i;
}
 BIN +224 Bytes configuration/example_cfg.bin 
Binary file not shown.
 44  dockerfiles/1_build_saffire.Dockerfile 
@@ -0,0 +1,44 @@
# 2022 eCTF
# Host-Tools and Bootloader Creation Dockerfile
# Andrew Mirghassemi
#
# (c) 2022 The MITRE Corporation
#
# This source file is part of an example system for MITRE's 2022 Embedded System
# CTF (eCTF). This code is being provided only for educational purposes for the
# 2022 MITRE eCTF competition, and may not meet MITRE standards for quality.
# Use this code at your own risk!
#
# DO NOT MODIFY THIS FILE

FROM ubuntu:focal

# Add environment customizations here
# NOTE: do this first so Docker can used cached containers to skip reinstalling everything
RUN apt-get update && apt-get upgrade -y && \
    apt-get install -y python3 \
    binutils-arm-none-eabi gcc-arm-none-eabi make

# Create bootloader binary folder
RUN mkdir /bootloader

# Add any system-wide secrets here
RUN mkdir /secrets

# Add host tools and bootloader source to container
ADD host_tools/ /host_tools
ADD bootloader /bl_build

# Generate Secrets
RUN /host_tools/generate_secrets

# Create EEPROM contents
RUN echo "Bootloader Data" > /bootloader/eeprom.bin

# Compile bootloader
WORKDIR /bl_build

ARG OLDEST_VERSION
RUN make OLDEST_VERSION=${OLDEST_VERSION}
RUN mv /bl_build/gcc/bootloader.bin /bootloader/bootloader.bin
RUN mv /bl_build/gcc/bootloader.axf /bootloader/bootloader.elf 
 38  dockerfiles/2_create_device.Dockerfile 
@@ -0,0 +1,38 @@
# 2022 eCTF
# Device Packager Dockerfile
# Andrew Mirghassemi
#
# (c) 2022 The MITRE Corporation
#
# This source file is part of an example system for MITRE's 2022 Embedded System
# CTF (eCTF). This code is being provided only for educational purposes for the
# 2022 MITRE eCTF competition, and may not meet MITRE standards for quality.
# Use this code at your own risk!
#
# DO NOT MODIFY THIS FILE

ARG SYSNAME
ARG PARENT
FROM ${SYSNAME}/host_tools as host_tools

FROM ${PARENT}

RUN apk update && apk upgrade && apk add python3

# Add environment customizations here
# NOTE: do this first so Docker can used cached containers to skip reinstalling everything

# Keep bootloader and EEPROM binaries
COPY --from=host_tools /bootloader /bootloader

# Pull in rest of platform
ADD platform/ /platform

# Create emulator state folders
RUN mkdir /flash
RUN mkdir /eeprom

RUN ls /platform

# Create padded binaries for the system bootstrappers
RUN /platform/create_images
 BIN +1.31 KB firmware/example_fw.bin 
Binary file not shown.
 329  getting_started.md 
@@ -0,0 +1,329 @@
# 2022 MITRE eCTF Getting Started

## Creating Your Own Fork
We suggest you create a fork of this repo so that you can begin to develop
your solution to the eCTF. To do this, you must fork the repo, change your
fork to the `origin`, and then add the example repo as another remote.
Follow these steps below.

1. Clone the eCTF repository using ssh or https 
```bash
git clone https://github.com/mitre-cyber-academy/2022-ectf-insecure-example --recursive
``` 

2. Change the current origin remote to another name
```bash
git remote rename origin example
```

3. Fork the example repo on github or create a repository on another hosting service.
   **You probably want to make the repo private for now so that other teams
   cannot borrow your development ideas** 

5. Add the new repository as the new origin
```bash
git remote add origin <url>
```

You can now fetch and push as you normally would using `git fetch origin` and
`git push origin`. If we push out updated code, you can fetch this new code
using `git fetch example`.


## Environment Setup

When running this code for the first time, you must pull the newest version of
the eCTF custom QEMU (emulator) for use in the challenge. Run the following to
get the appropriate emulator image:

```bash
docker pull ectf/ectf-qemu:tiva
```

## Creating and Launching a Deployment

To launch the example SAFFIRe system (**and earn the Boot Reference flag**),
follow these steps. **Note: you can change the values of these arguments.
Since all team members log in on the same user, you may end up interfering with
each other's containers. To avoid that, use different `--sysname` and
`--uart-sock` values. We recommend each team member choosing a unique socket for
`--uart-sock` for the duration of the design phase.**

These steps should work on the development servers we provide out of the box.
If you would like to use the physical hardware, you must follow the environment
set-up instructions and use the `--physical` flag in place of `--emulated`
(NOTE: the physical hardware is not supported in the initial code release).

Please refer to the technical specifications document for explanations of 
the commands and arguments.

### 1. Building the Deployment

A deployment (host-tools + bootloader) is created using:

```bash
python3 tools/run_saffire.py build-system --emulated \
    --sysname saffire-test \
    --oldest-allowed-version 1
```

This will create two Docker images based on the host-tools and bootloader in the
repo:

- saffire-test/host_tools
- saffire-test/bootloader


### 2. Launch the Bootloader

The bootloader must first be loaded:

```bash
python3 tools/run_saffire.py load-device --emulated --sysname saffire-test
```

Then, a directory should be made for the sockets, after which the bootloader can
be launched:

```bash
mkdir socks
python3 tools/run_saffire.py launch-bootloader --emulated  \
    --sysname saffire-test \
    --sock-root socks/ \
    --uart-sock 1337
```

There are two alternative variants to this step, controlled by replacing
the `launch-bootloader` argument.
To connect GDB to the bootloader, use `launch-bootloader-gdb`. This will
start QEMU up, pausing at the first instruction until GDB is connected. The command
will print the GDB command to use to connect to the system. **NOTE: The bootloader
will not run in this mode until GDB has been attached and starts the bootloader.**
If you run with GDB, you will have to open another terminal to run the host tools.

Alternatively, to see the output of the Docker container running QEMU, use
`launch-bootloader-interractive`. One case where this is helpful is if you are
unsure whether the host tools or GDB is connecting to the bootloader. Info messages
are printed in the bootloader container when processes connect and disconnect.
If you run in interactive mode, you will have to open another terminal to run
the host tools.

### 3. Protect the SAFFIRe Files

We now need to protect the firmware and configuration files.
This can be done with the following commands:

```bash
python3 tools/run_saffire.py fw-protect --emulated \
    --sysname saffire-test \
    --fw-root firmware/ \
    --raw-fw-file example_fw.bin \
    --protected-fw-file example_fw.prot \
    --fw-version 2 \
    --fw-message 'hello world'
python3 tools/run_saffire.py cfg-protect --emulated \
    --sysname saffire-test \
    --cfg-root configuration/ \
    --raw-cfg-file example_cfg.bin \
    --protected-cfg-file example_cfg.prot
```

The release message passed to `fw_protect` must be formatted as shown above, as
the quotation marks are required for passing the full string into the protect
tool as one argument. The escaped quotation marks '' are there for that purpose.


### 4. Update and Load the Bootloader

Now that we have protected firmware and configuration images, we can
load them onto the device with the following commands:

```bash
python3 tools/run_saffire.py fw-update --emulated \
    --sysname saffire-test \
    --fw-root firmware/ \
    --uart-sock 1337 \
    --protected-fw-file example_fw.prot
python3 tools/run_saffire.py cfg-load --emulated \
    --sysname saffire-test \
    --cfg-root configuration/ \
    --uart-sock 1337 \
    --protected-cfg-file example_cfg.prot
```

After this, the bootloader should now be ready to handle readback and boot commands.

### 5. Readback

With firmware and configurations loaded onto the bootloader, we can now use the
readback functionality with the following commands:

```bash
python3 tools/run_saffire.py fw-readback --emualted \
    --sysname saffire-test \
    --uart-sock 1337 \
    --rb-len 100
python3 tools/run_saffire.py cfg-readback --emulated \
    --sysname saffire-test \
    --uart-sock 1337 \
    --rb-len 100
```

You may use a tool like xxd to verify that the output of the readback tool matches
the unprotected firmware.

### 6. Boot firmware

With firmware and configurations loaded onto the bootloader, we can now boot the device:

```bash
python3 tools/run_saffire.py boot --emulated \
    --sysname saffire-test \
    --uart-sock 1337 \
    --boot-msg-file boot.txt
python3 tools/run_saffire.py monitor --emulated \
    --sysname saffire-test \
    --uart-sock 1337 \
    --boot-msg-file boot.txt
```

This first command tells the SAFFIRe bootloader to launch the firmware, printing
the boot message to the file `boot.txt` (which remains in the Docker container).
If this is successful and a release message was printed, the second command will
launch and monitor the output of the rest of the airplane, simulating a flight.

**IF EVERYTHING WORKS PROPERLY, CHECK THE OUTPUT OF THE MONITOR COMMAND FOR A FLAG**


### 8. Restarting the Bootloader

Any time you want to perform a soft reset on the microcontroller to restart the
bootloader, you can do so with:

```bash
python3 tools/emulator_reset.py --restart-sock socks/restart.sock
```

If you specified a different socket root with `--sock-root` when running
`launch-bootloader`, make sure to replace `socks/restart.sock` with the correct
path when running the reset tool.


### 7. Shutting Down the Bootloader

When you're done with the bootloader or would just like to rebuild, you can do so
with:

```bash
python3 tools/run_saffire.py kill-system --emulated --sysname saffire-test
```


## Automating SAFFIRe Operation

### Scripting

We recommend creating scripts to run multiple SAFFIRe commands in a row. Two
useful scripts to create could be called `run_setup.sh` that runs the
`kill-system`, `build-system`, `load-device`, and `launch-bootloader` steps, and
`run_tools.sh` that runs the rest of the steps. This will make it easy to run
the host tools alongside a bootloader that has been launched in GDB or interactive
mode.

### Automatic Arguments

`tools/run_saffire.py` is set up to optionally read arguments from a file. The
arguments used in the above example commands are replicated in the example
arguments file `saffire.cfg`. For example, to run the same `launch-bootloader`
shown above using the argument file, run the following:

```bash
python3 tools/run_saffire.py launch-bootloader @saffire.cfg --emulated
```

Using an argument file makes it easy to re-use the same arguments for multiple
commands to reduce typing and typos. You can create multiple argument files and
use them for different configurations and testing.

Finally, if you want to override an argument specified in an argument file you
can specify the argument at the end of the command. For example, to run the
following example but with a different socket number, use the following:

```bash
python3 tools/run_saffire.py launch-bootloader @saffire.cfg --uart-sock=1338
```


## Using the Debugger

By using the `launch-bootloader-gdb` command, you can easily attach GDB
to the bootloader. To see the output of the host tools in real time, you will
have to run the debugger and host tools in separate windows. 

**Quick GDB Reference:**

- Set a function breakpoint: `b <function_name>`
- Set a breakpoint at an address: `b *0x<memory_address>`
- View memory location: `x 0x<memory address>`
- Continue execution: `c` or `continue`
- Step one instruction: `si`
- View CPU registers: `info registers` or `i r`
- Disassemble current context: `disas`
- Disassemble arbitrary location: `disas 0x<memory_address>, +0x<number_of_locations_to_show>`
- Switch the layout to view the assembly: `layout asm`
- Quit GDB: `quit` -- you may have to hit `y` and press enter if it asks you confirm the exit
    - If the debugger is running and it is not hitting breakpoints Hit `CTRL-C` first to pause

There are plenty of resources online for how to use GDB, and your teammates and
advisors can likely give you tips as well.


## Docker tricks

To view all running Docker containers:
```
docker ps
```

To kill the Docker container with process ID 12345:
```
docker kill 12345
```

To kill all Docker containers (be aware not to kill the containers of others on the server):
```
docker kill $(docker ps -q)
```
You can streamline this by adding `alias dockerka='docker kill $(docker ps -q)'` to your `.bashrc`.

To run a command in the Docker container `test:deployment`:
```
docker run test:deployment echo "this echo command will be run in the container"
```

Docker can chew up disk space, so if you need to reclaim some, first clean up unused
containers and volumes
```
docker container prune
docker volume prune
```

If that isn't enough, you can clean up all containers and volumes:
```
docker container prune -a
docker volume prune -a
```
NOTE: these will remove all of the cached containers, so the next builds may take a longer time


## Helpful Tricks

The example code is set up to clean up the system state when running `kill-system`.
But, when you are developing and things break, these are some helpful commands
to have handy.

- **Kill all docker containers**: `docker kill $(docker ps -q)`
- **Remove all sockets**: `rm -rf socks/*`
- **Kill the process in your window**: `CTRL-C`
- **Suspend the process in your window**: `CTRL-Z`
  - **Note:** Make sure to kill the process after!
 7  host_tools/README.md 
@@ -0,0 +1,7 @@
# Host Tools

This folder holds all of the host tools. We have included an example secret
generation script (it's not very secret though, is it?) to show how commands can
be called during the system build (`1_build_saffire.Dockerfile`) process.
You are not required to have a `secret_generator`, and any files saved in this
folder will be available during the system build process.
 0  host_tools/__init__.py 
Empty file.
 88  host_tools/boot 
@@ -0,0 +1,88 @@
#!/usr/bin/python3 -u

# 2022 eCTF
# Boot Tool
# Kyle Scaplen
#
# (c) 2022 The MITRE Corporation
#
# This source file is part of an example system for MITRE's 2022 Embedded System
# CTF (eCTF). This code is being provided only for educational purposes for the
# 2022 MITRE eCTF competition, and may not meet MITRE standards for quality.
# Use this code at your own risk!

import argparse
import logging
from pathlib import Path
import socket

from util import print_banner, RELEASE_MESSAGES_ROOT, LOG_FORMAT

logging.basicConfig(level=logging.INFO, format=LOG_FORMAT)
log = logging.getLogger(Path(__file__).name)


def boot(socket_number: int, release_message_file: Path):
    print_banner("SAFFIRe Firmware Boot Tool")

    # Connect to the bootloader
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
        sock.connect(("localhost", socket_number))

        # Send boot command
        log.info("Sending boot command...")
        sock.send(b"B")

        # Receive bootloader acknowledgement
        log.info("Waiting for bootloader to enter boot mode...")
        while sock.recv(1) != b"B":
            pass

        # Wait for bootloader to move firmware to ram
        log.info("Waiting for bootloader to copy firmware to RAM...")
        msg = sock.recv(1)
        if msg != b"M":
            exit(f"Boot failed with code {repr(msg)}")

        # Receive release message
        log.info("Receiving release message...")
        release_msg = sock.recv(1)
        while release_msg[-1] != 0:
            release_msg += sock.recv(1)

        log.info(f"Release Message: {release_msg}")

        # Write release message to file
        log.info("Writing release message to output file...")
        release_message_file.write_text(release_msg.decode("latin-1"))

        log.info("Firmware booted\n")

        # Exit successfully
        exit(0)


def main():
    parser = argparse.ArgumentParser()

    parser.add_argument(
        "--socket",
        help="Port number of the socket to connect the host to the bootloader.",
        type=int,
        required=True,
    )
    parser.add_argument(
        "--release-message-file",
        help="Name of a file to store the release message in.",
        required=True,
    )

    args = parser.parse_args()

    release_message_file = RELEASE_MESSAGES_ROOT / args.release_message_file

    boot(args.socket, release_message_file)


if __name__ == "__main__":
    main()
 84  host_tools/cfg_load 
@@ -0,0 +1,84 @@
#!/usr/bin/python3 -u

# 2022 eCTF
# Configure Tool
# Kyle Scaplen
#
# (c) 2022 The MITRE Corporation
#
# This source file is part of an example system for MITRE's 2022 Embedded System
# CTF (eCTF). This code is being provided only for educational purposes for the
# 2022 MITRE eCTF competition, and may not meet MITRE standards for quality.
# Use this code at your own risk!

import argparse
import logging
from pathlib import Path
import socket
import struct

from util import print_banner, send_packets, RESP_OK, CONFIGURATION_ROOT, LOG_FORMAT

logging.basicConfig(level=logging.INFO, format=LOG_FORMAT)
log = logging.getLogger(Path(__file__).name)


def load_configuration(socket_number: int, config_file: Path):
    print_banner("SAFFIRe Configuration Tool")

    log.info("Reading configuration file...")
    configuration = config_file.read_bytes()
    size = len(configuration)

    # Connect to the bootloader
    log.info("Connecting socket...")
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
        sock.connect(("localhost", socket_number))

        # Send configure command
        log.info("Sending configure command...")
        sock.sendall(b"C")

        # Receive bootloader acknowledgement
        while sock.recv(1) != b"C":
            pass

        # Send the size
        log.info("Sending the size...")
        payload = struct.pack(">I", size)
        sock.send(payload)
        response = sock.recv(1)
        if response != RESP_OK:
            exit(f"ERROR: Bootloader responded with {repr(response)}")

        # Send packets
        send_packets(sock, configuration)

        log.info("Firmware configured\n")


def main():
    # get arguments
    parser = argparse.ArgumentParser()

    parser.add_argument(
        "--socket",
        help="Port number of the socket to connect the host to the bootloader.",
        type=int,
        required=True,
    )
    parser.add_argument(
        "--config-file",
        help="Name of the protected configuration to load.",
        required=True,
    )

    args = parser.parse_args()

    config_file = CONFIGURATION_ROOT / args.config_file

    load_configuration(args.socket, config_file)


if __name__ == "__main__":
    main()
 59  host_tools/cfg_protect 
@@ -0,0 +1,59 @@
#!/usr/bin/python3 -u

# 2022 eCTF
# Protect Configuration Tool
# Kyle Scaplen
#
# (c) 2022 The MITRE Corporation
#
# This source file is part of an example system for MITRE's 2022 Embedded System
# CTF (eCTF). This code is being provided only for educational purposes for the
# 2022 MITRE eCTF competition, and may not meet MITRE standards for quality.
# Use this code at your own risk!

import argparse
import logging
from pathlib import Path

from util import print_banner, CONFIGURATION_ROOT, LOG_FORMAT

logging.basicConfig(level=logging.INFO, format=LOG_FORMAT)
log = logging.getLogger(Path(__file__).name)


def protect_configuration(raw_cfg: Path, protected_cfg: Path):
    print_banner("SAFFIRe Configuration Protect Tool")

    # Read in the raw configuration binary
    log.info("Reading configuration data...")
    file_data = raw_cfg.read_bytes()

    log.info("Packaging the configuration...")

    # Write to the output file
    protected_cfg.write_bytes(file_data)

    log.info("Configuration protected\n")


def main():
    # get arguments
    parser = argparse.ArgumentParser()

    parser.add_argument(
        "--input-file", help="The name of the configuration to protect.", required=True
    )
    parser.add_argument(
        "--output-file", help="The name of the protected configuration.", required=True
    )

    args = parser.parse_args()

    # process command
    raw_cfg = CONFIGURATION_ROOT / args.input_file
    protected_cfg = CONFIGURATION_ROOT / args.output_file
    protect_configuration(raw_cfg, protected_cfg)


if __name__ == "__main__":
    main()
 82  host_tools/fw_protect 
@@ -0,0 +1,82 @@
#!/usr/bin/python3 -u

# 2022 eCTF
# Protect Firmware Tool
# Kyle Scaplen
#
# (c) 2022 The MITRE Corporation
#
# This source file is part of an example system for MITRE's 2022 Embedded System
# CTF (eCTF). This code is being provided only for educational purposes for the
# 2022 MITRE eCTF competition, and may not meet MITRE standards for quality.
# Use this code at your own risk!

import argparse
import json
import logging
from pathlib import Path

from util import print_banner, FIRMWARE_ROOT, LOG_FORMAT

logging.basicConfig(level=logging.INFO, format=LOG_FORMAT)
log = logging.getLogger(Path(__file__).name)


def protect_firmware(
    firmware_file: Path, version: int, release_message: str, protected_firmware: Path
):
    print_banner("SAFFIRe Firmware Protect Tool")

    # Read in the raw firmware binary
    log.info("Reading the firmware...")
    firmware_data = firmware_file.read_bytes()

    log.info("Packaging the firmware...")

    # Construct the metadata
    firmware_size = len(firmware_data)

    # Create firmware storage structure
    data = {
        "firmware_size": firmware_size,
        "version_num": version,
        "release_msg": release_message,
        "firmware": firmware_data.hex(),
    }

    # Write to the output file
    with protected_firmware.open("w", encoding="utf8") as fd:
        json.dump(data, fd)

    log.info("Firmware protected\n")


def main():
    # get arguments
    parser = argparse.ArgumentParser()

    parser.add_argument(
        "--firmware", help="The name of the firmware image to protect.", required=True
    )
    parser.add_argument(
        "--version", help="The version of this firmware.", type=int, required=True
    )
    parser.add_argument(
        "--release-message", help="The release message of this firmware.", required=True
    )
    parser.add_argument(
        "--output-file", help="The name of the protected firmware image.", required=True
    )

    args = parser.parse_args()

    # process command
    firmware_file = FIRMWARE_ROOT / args.firmware
    protected_firmware = FIRMWARE_ROOT / args.output_file
    protect_firmware(
        firmware_file, args.version, args.release_message, protected_firmware
    )


if __name__ == "__main__":
    main()
 93  host_tools/fw_update 
@@ -0,0 +1,93 @@
#!/usr/bin/python3 -u

# 2022 eCTF
# Update Tool
# Kyle Scaplen
#
# (c) 2022 The MITRE Corporation
#
# This source file is part of an example system for MITRE's 2022 Embedded System
# CTF (eCTF). This code is being provided only for educational purposes for the
# 2022 MITRE eCTF competition, and may not meet MITRE standards for quality.
# Use this code at your own risk!

import argparse
import json
import logging
from pathlib import Path
import socket
import struct

from util import print_banner, send_packets, RESP_OK, FIRMWARE_ROOT, LOG_FORMAT

logging.basicConfig(level=logging.INFO, format=LOG_FORMAT)
log = logging.getLogger(Path(__file__).name)


def update_firmware(socket_number: int, firmware_file: Path):
    print_banner("SAFFIRe Firmware Update Tool")

    log.info("Reading firmware file...")
    with firmware_file.open("rb") as fw:
        data = json.load(fw)
        version_num: int = data["version_num"]
        release_msg: str = data["release_msg"]
        firmware = bytes.fromhex(data["firmware"])
        firmware_size = len(firmware)

    # Connect to the bootloader
    log.info("Connecting socket...")
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
        sock.connect(("localhost", socket_number))

        # Send update command
        log.info("Sending update command...")
        sock.send(b"U")

        # Receive bootloader acknowledgement
        log.info("Waiting for bootloader to enter update mode...")
        while sock.recv(1) != b"U":
            pass

        # Send the version, size, and release message
        log.info("Sending version, size, and release message...")
        payload = (
            struct.pack(">HI", version_num, firmware_size)
            + release_msg.encode()
            + b"\x00"
        )
        sock.send(payload)
        response = sock.recv(1)
        if response != RESP_OK:
            exit(f"ERROR: Bootloader responded with {repr(response)}")

        # Send packets
        log.info("Sending firmware packets...")
        send_packets(sock, firmware)

        log.info("Firmware updated\n")


def main():
    # get arguments
    parser = argparse.ArgumentParser()

    parser.add_argument(
        "--socket",
        help="Port number of the socket to connect the host to the bootloader.",
        type=int,
        required=True,
    )
    parser.add_argument(
        "--firmware-file", help="Name of the firmware image to load.", required=True
    )

    args = parser.parse_args()

    firmware_file = FIRMWARE_ROOT / args.firmware_file

    update_firmware(args.socket, firmware_file)


if __name__ == "__main__":
    main()
 14  host_tools/generate_secrets 
@@ -0,0 +1,14 @@
#!/bin/bash

# 2022 eCTF
# Example Generate secrets
# Jake Grycel
#
# (c) 2022 The MITRE Corporation
#
# This source file is part of an example system for MITRE's 2022 Embedded System
# CTF (eCTF). This code is being provided only for educational purposes for the
# 2022 MITRE eCTF competition, and may not meet MITRE standards for quality.
# Use this code at your own risk!

echo "SECRETS" >> /secrets/secrets.txt
 137  host_tools/monitor 
@@ -0,0 +1,137 @@
#!/usr/bin/python3 -u

# 2022 eCTF
# Example Firmware Bus Monitor
# Kyle Scaplen
#
# (c) 2022 The MITRE Corporation
#
# This source file is part of an example system for MITRE's 2022 Embedded System
# CTF (eCTF). This code is being provided only for educational purposes for the
# 2022 MITRE eCTF competition, and may not meet MITRE standards for quality.
# Use this code at your own risk!

import argparse
import logging
import socket
from pathlib import Path

from util import print_banner, RELEASE_MESSAGES_ROOT, LOG_FORMAT

logging.basicConfig(level=logging.INFO, format=LOG_FORMAT)
log = logging.getLogger(Path(__file__).name)


def monitor(socket_number: int, mfile: str):
    # Monitor Header
    print_banner("CTF Systems Avionics Bus Controller v5.7 - eCTF Organizers 2022")

    # Construct the socket and release message file paths
    mfile = RELEASE_MESSAGES_ROOT / mfile

    # Print release message
    log.info("*** Firmware Release Message ***\n")

    log.info(mfile.read_text(encoding="latin-1"))

    # Connect to the firmware
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as hsock:
        hsock.connect(("localhost", socket_number))

        try:
            # Send init command
            log.info("Initializing aircraft sensors")
            hsock.send(b"I")

            # Get status
            data = hsock.recv(4096)
            while data[-1] != 1:
                data = data + hsock.recv(4096)
            data = data[:-1]

            # Print response
            for s in data.decode("latin-1").split("\n"):
                log.info(f"Response: {s}")

            # Send start command
            log.info("Starting aircraft operation")
            hsock.send(b"S")

            # Get data
            data = hsock.recv(4096)
            while data[-1] != 1:
                data = data + hsock.recv(4096)
            data = data[:-1]

            # Print response
            for s in data.decode("latin-1").split("\n"):
                log.info(f"Response: {s}")

            # "Confirm" correct altitude
            log.info("Correct altitude -- flight will continue")
            hsock.send(b"Y")

            # Get receive confirmation
            data = hsock.recv(4096)
            while data[-1] != 1:
                data = data + hsock.recv(4096)
            data = data[:-1]

            # Print response
            for s in data.decode("latin-1").split("\n"):
                log.info(f"Response: {s}")

            # Request configuration
            log.info("Collecting flight configuration")
            hsock.send(b"C")

            # Get the configuration
            data = hsock.recv(4096)
            while data[-1] != 1:
                data = data + hsock.recv(4096)
            data = data[:-1]

            for s in data.decode("latin-1").split("\n"):
                log.info(f"Flight Configuration: {s}")

            # End
            log.info("Ending")
            hsock.send(b"E")

            # Get the final message
            data = hsock.recv(4096)
            while data[-1] != 1:
                data = data + hsock.recv(4096)
            data = data[:-1]

            for s in data.decode("latin-1").split("\n"):
                log.info(f"Final Response: {s}")

            # End
            log.info("Exiting.")
        except KeyboardInterrupt:
            log.warning("Monitor Cancelled. Exiting")


def main():
    parser = argparse.ArgumentParser()

    parser.add_argument(
        "--socket",
        help="Name of the socket to connect the host to the bootloader.",
        type=int,
        required=True,
    )
    parser.add_argument(
        "--release-message-file",
        help="Path to file with the release message.",
        required=True,
    )

    args = parser.parse_args()

    monitor(args.socket, args.release_message_file)


if __name__ == "__main__":
    main()
 110  host_tools/readback 
@@ -0,0 +1,110 @@
#!/usr/bin/python3 -u

# 2022 eCTF
# Memory Readback Tool
# Kyle Scaplen
#
# (c) 2022 The MITRE Corporation
#
# This source file is part of an example system for MITRE's 2022 Embedded System
# CTF (eCTF). This code is being provided only for educational purposes for the
# 2022 MITRE eCTF competition, and may not meet MITRE standards for quality.
# Use this code at your own risk!

import argparse
import logging
import socket
from pathlib import Path

from util import print_banner, LOG_FORMAT

logging.basicConfig(level=logging.INFO, format=LOG_FORMAT)
log = logging.getLogger(Path(__file__).name)


def readback(socket_number, region, num_bytes):
    # Print Banner
    print_banner("SAFFIRe Memory Readback Tool")

    # Connect to the bootoader
    log.info("Connecting socket...")
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
        sock.connect(("localhost", socket_number))

        # Send readback command
        log.info("Sending readback command...")
        sock.send(b"R")

        # Receive bootloader acknowledgement
        log.info("Waiting for bootloader to enter readback mode...")
        while sock.recv(1) != b"R":
            pass

        # Send the region identifier
        log.info("Sending the region identifier to read back...")
        if region == "firmware":
            # send firmware identifier
            sock.send(b"F")
            # get acknowledgement
            log.info("Waiting for bootloader to confirm the region...")
            while sock.recv(1) != b"F":
                pass
        elif region == "configuration":
            # send configuration identifier
            sock.send(b"C")
            # get acknowledgement
            log.info("Waiting for bootloader to confirm the region...")
            while sock.recv(1) != b"C":
                pass
        else:
            # send character other than an identifier to exit readback
            sock.send(b"Q")
            return

        # Send the number of bytes to read
        size = int.to_bytes(num_bytes, 4, "big")
        sock.send(size)

        # Receive firmware data
        log.info("Receiving firmware...")
        bytes_remaining = num_bytes
        fw = b""
        while bytes_remaining > 0:
            num_bytes = 4096 if bytes_remaining > 4096 else bytes_remaining
            data = sock.recv(num_bytes)
            num_received = len(data)
            fw += data
            bytes_remaining -= num_received

        log.info(f"Memory Readback Data: {fw.hex()}\n")


def main():
    parser = argparse.ArgumentParser()

    parser.add_argument(
        "--socket",
        help="Port number of the socket to connect the host to the bootloader.",
        type=int,
        required=True,
    )
    parser.add_argument(
        "--region",
        help="The region to read.",
        choices=["firmware", "configuration"],
        required=True,
    )
    parser.add_argument(
        "--num-bytes",
        help="The number of bytes to read from the region.",
        type=int,
        required=True,
    )

    args = parser.parse_args()

    readback(args.socket, args.region, args.num_bytes)


if __name__ == "__main__":
    main()
 63  host_tools/util.py 
@@ -0,0 +1,63 @@
# 2022 eCTF
# Host Tool Utility File
# Kyle Scaplen
#
# (c) 2022 The MITRE Corporation
#
# This source file is part of an example system for MITRE's 2022 Embedded System
# CTF (eCTF). This code is being provided only for educational purposes for the
# 2022 MITRE eCTF competition, and may not meet MITRE standards for quality.
# Use this code at your own risk!

import logging
from pathlib import Path
import socket
from sys import stderr

LOG_FORMAT = "%(asctime)s:%(name)-12s%(levelname)-8s %(message)s"
log = logging.getLogger(Path(__file__).name)

CONFIGURATION_ROOT = Path("/configuration")
FIRMWARE_ROOT = Path("/firmware")
RELEASE_MESSAGES_ROOT = Path("/messages")

RESP_OK = b"\x00"


def print_banner(s: str) -> None:
    """Print an underlined string to stdout
    Args:
        s (str): the string to print
    """
    width = len(s)
    line = "-" * width
    banner = f"\n{line}\n{s}\n{line}"
    print(banner, file=stderr)


class PacketIterator:
    BLOCK_SIZE = 0x400

    def __init__(self, data: bytes):
        self.data = data
        self.index = 0
        self.size = len(data)

    def __iter__(self):
        return [
            self.data[i : i + self.BLOCK_SIZE]
            for i in range(0, len(self.data), self.BLOCK_SIZE)
        ].__iter__()


def send_packets(sock: socket.socket, data: bytes):
    packets = PacketIterator(data)

    for num, packet in enumerate(packets):
        log.debug(f"Sending Packet {num} ({len(packet)} bytes)...")
        sock.sendall(packet)
        resp = sock.recv(1)  # Wait for an OK from the bootloader

        if resp != RESP_OK:
            exit(f"ERROR: Bootloader responded with {repr(resp)}")
 6  platform/README.md 
@@ -0,0 +1,6 @@
# Device Platform

**Nothing in this folder should be modified** Feel free to read and understand
this code, but none of it is necessary for implementing your design. This code
is responsible for starting the emulator and preparing the necessary design
images for the emulated and physical platforms.
 217  platform/bl_interface.py 
@@ -0,0 +1,217 @@
# 2022 eCTF
# Bootloader Interface Emulator
# Ben Janis
#
# (c) 2022 The MITRE Corporation
#
# This source file is part of an example system for MITRE's 2022 Embedded System
# CTF (eCTF). This code is being provided only for educational purposes for the
# 2022 MITRE eCTF competition, and may not meet MITRE standards for quality.
# Use this code at your own risk!
#
# DO NOT CHANGE THIS FILE

import argparse
import os
import logging
import socket
import select
from pathlib import Path
from typing import List, Optional, TypeVar

Message = TypeVar("Message")
LOG_FORMAT = "%(asctime)s:%(name)-s%(levelname)-8s %(message)s"


class Sock:
    def __init__(
        self,
        sock_path: str,
        q_len=1,
        log_level=logging.INFO,
        mode: int = None,
        network=False,
    ):
        self.sock_path = sock_path
        self.network = network
        self.buf = b""

        # set up socket
        if self.network:
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            self.sock.bind(("localhost", int(sock_path)))
        else:
            # Make sure the socket does not already exist
            try:
                os.unlink(sock_path)
            except OSError:
                if os.path.exists(sock_path):
                    raise
            self.sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            self.sock.bind(sock_path)

        self.sock.listen(q_len)
        self.csock = None

        # change permissions if necessary
        if mode and not self.network:
            os.chmod(sock_path, mode)

        # set up logger
        fhandler = logging.FileHandler("bl_interface.log")
        fhandler.setLevel(log_level)
        fhandler.setFormatter(logging.Formatter(LOG_FORMAT))

        shandler = logging.StreamHandler()
        shandler.setLevel(log_level)
        shandler.setFormatter(logging.Formatter(LOG_FORMAT))

        self.logger = logging.getLogger(f"{sock_path}_log")
        self.logger.addHandler(shandler)
        self.logger.setLevel(log_level)

    @staticmethod
    def sock_ready(sock: socket.SocketType) -> bool:
        ready, _, _ = select.select([sock], [], [], 0)
        return bool(ready)

    def active(self) -> bool:
        # try to accept new client
        if not self.csock:
            if self.sock_ready(self.sock):
                self.logger.info(f"Connection opened on {self.sock_path}")
                self.csock, _ = self.sock.accept()
        return bool(self.csock)

    def deserialize(self) -> bytes:
        buf = self.buf
        self.buf = b""
        return buf

    def read_msg(self) -> Optional[Message]:
        if not self.active():
            return None

        try:
            if self.sock_ready(self.csock):
                data = self.csock.recv(4096)

                # connection closed
                if not data:
                    self.close()
                    return None

                self.buf += data

            return self.deserialize()
        except (ConnectionResetError, BrokenPipeError):
            # cleanly handle forced closed connection
            self.close()
            return None

    def read_all_msgs(self) -> List[Message]:
        msgs = []
        msg = self.read_msg()
        while msg:
            msgs.append(msg)
            msg = self.read_msg()
        return msgs

    @staticmethod
    def serialize(msg: bytes) -> bytes:
        return msg

    def send_msg(self, msg: Message) -> bool:
        if not self.active():
            return False

        try:
            self.csock.sendall(self.serialize(msg))
            return True
        except (ConnectionResetError, BrokenPipeError):
            # cleanly handle forced closed connection
            self.close()
            return False

    def close(self):
        self.logger.warning(f"Conection closed on {self.sock_path}")
        self.csock = None
        self.buf = b""


def poll_data_socks(device_sock: Sock, host_sock: Sock):
    if device_sock.active():
        msg = device_sock.read_msg()

        # send message to host
        if host_sock.active():
            if msg is not None:
                host_sock.send_msg(msg)

    if host_sock.active():
        msg = host_sock.read_msg()

        # send message to device
        if device_sock.active():
            if msg is not None:
                device_sock.send_msg(msg)


def poll_restart_socks(device_sock: Sock, host_sock: Sock):
    # First check that device opened a restart port
    if device_sock.active():
        # Send host restart commands to device
        if host_sock.active():
            msg = host_sock.read_msg()
            if msg is not None:
                device_sock.send_msg(msg)


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--data-bl-sock",
        type=Path,
        required=True,
        help="Path to device-side data socket (will be created)",
    )
    parser.add_argument(
        "--data-host-sock",
        type=int,
        required=True,
        help="Port for host-side data socket (must be available)",
    )
    parser.add_argument(
        "--restart-bl-sock",
        type=Path,
        required=True,
        help="Path to device-side data socket (will be created)",
    )
    parser.add_argument(
        "--restart-host-sock",
        type=Path,
        required=True,
        help="Path to device-side data socket (will be created)",
    )
    return parser.parse_args()


def main():
    args = parse_args()

    # open all sockets
    data_bl = Sock(str(args.data_bl_sock), mode=0o777)
    data_host = Sock(str(args.data_host_sock), mode=0o777, network=True)

    restart_bl = Sock(str(args.restart_bl_sock), mode=0o777)
    restart_host = Sock(str(args.restart_host_sock), mode=0o777)

    # poll sockets forever
    while True:
        poll_data_socks(data_bl, data_host)
        poll_restart_socks(restart_bl, restart_host)


if __name__ == "__main__":
    main()
 70  platform/create_images 
@@ -0,0 +1,70 @@
#!/usr/bin/python3

# 2022 eCTF
# Create images for bootstrappers
# Jake Grycel
#
# (c) 2022 The MITRE Corporation
#
# This source file is part of an example system for MITRE's 2022 Embedded System
# CTF (eCTF). This code is being provided only for educational purposes for the
# 2022 MITRE eCTF competition, and may not meet MITRE standards for quality.
# Use this code at your own risk!
#
# DO NOT CHANGE THIS FILE

from pathlib import Path

FLASH_SIZE = 256 * 1024
FLASH_FRONT_SIZE = 0x5800
IMAGE_BL_SIZE = 115 * 1024
EEPROM_SIZE = 2 * 1024


# Input bootloader and EEPROM images
source_bl = Path("/bootloader/bootloader.bin")
source_eeprom = Path("/bootloader/eeprom.bin")

# Output binaries
out_flash = Path("/flash/flash.bin")
out_eeprom = Path("/eeprom/eeprom.bin")
out_phys_image = Path("/bootloader/phys_image.bin")

# Read input binaries
with open(source_bl, "rb") as fp:
    bl_data = fp.read()

with open(source_eeprom, "rb") as fp:
    eeprom_data = fp.read()

# Pad front of bootloader for flash.bin
flash_front_padding = bytes([0xFF] * FLASH_FRONT_SIZE)
flash_front_data = flash_front_padding + bl_data

# Pad back bootloader for flash.bin
flash_back_pad_len = FLASH_SIZE - len(flash_front_data)
flash_back_padding = bytes([0xFF] * flash_back_pad_len)
flash_data = flash_front_data + flash_back_padding

# Pad bootloader for phys_image.bin
image_bl_pad_len = IMAGE_BL_SIZE - len(bl_data)
image_bl_padding = bytes([0xFF] * image_bl_pad_len)
image_bl_data = bl_data + image_bl_padding

# Pad EEPROM
eeprom_pad_len = EEPROM_SIZE - len(eeprom_data)
eeprom_padding = bytes([0xFF] * eeprom_pad_len)
eeprom_data = eeprom_data + eeprom_padding

# Create phys_image.bin
image_data = image_bl_data + eeprom_data

# Write output binaries
with open(out_flash, "wb") as fp:
    fp.write(flash_data)

with open(out_eeprom, "wb") as fp:
    fp.write(eeprom_data)

with open(out_phys_image, "wb") as fp:
    fp.write(image_data)
 64  platform/launch_platform.sh 
@@ -0,0 +1,64 @@
#!/usr/bin/bash

# 2022 eCTF
# Stellaris platform launch script
# Jake Grycel
#
# (c) 2022 The MITRE Corporation
#
# This source file is part of an example system for MITRE's 2022 Embedded System
# CTF (eCTF). This code is being provided only for educational purposes for the
# 2022 MITRE eCTF competition, and may not meet MITRE standards for quality.
# Use this code at your own risk!
#
# DO NOT CHANGE THIS FILE

gdb_arg=""

# Parse args
while [ "$1" != "" ]; do
  case $1 in
    -u | --uart_sock )
        shift
        uart_sock=$1
        ;;
    -g | --gdb )
        gdb_arg="-gdb unix:/external_socks/gdb.sock,server"
        ;;
  esac
  shift
done

# Check required sockets
if [[ -z ${uart_sock} ]]; then
  echo "Please provide host socket"
  exit 1
fi

# Set up external emulator sockets
ext_sock_root="/external_socks"
ext_restart_sock="$ext_sock_root/restart.sock"
net_uart_sock="$uart_sock"

# Setup internal emulator sockets
int_sock_root="/internal_socks"
int_host_sock="$int_sock_root/host.sock"
int_restart_sock="$int_sock_root/restart.sock"
mkdir "$int_sock_root"

# Spin up the interface
python3 -u /platform/bl_interface.py --data-bl-sock "$int_host_sock" \
  --data-host-sock "$net_uart_sock" \
  --restart-bl-sock "$int_restart_sock" \
  --restart-host-sock "$ext_restart_sock" &

# Give time for the sockets and eFuse to initialize
sleep 2


# Spin up the emulator -- correct version (side-channel or not) is selected by makefile
qemu-system-arm -M lm3s6965evb -nographic -monitor none \
  ${gdb_arg} \
  -kernel /platform/bootstrapper_emu.elf \
  -serial unix:${int_host_sock} \
  -serial unix:${int_restart_sock} 
 1  requirements.txt 
@@ -0,0 +1 @@
pyserial==3.5
 14  saffire.cfg 
@@ -0,0 +1,14 @@
--sysname=saffire-test
--oldest-allowed-version=1
--sock-root=socks
--uart-sock=1337
--fw-root=firmware
--raw-fw-file=example_fw.bin
--protected-fw-file=example_fw.prot
--fw-version=2
--fw-message=Congratulations! The bootloader is booting the example images!
--cfg-root=configuration
--raw-cfg-file=example_cfg.bin
--protected-cfg-file=example_cfg.prot
--rb-len=100
--boot-msg-file=boot.txt 
 48  tools/emulator_reset.py 
@@ -0,0 +1,48 @@
#!/usr/bin/python3 -u

# 2022 eCTF
# Bootloader Restart Utility
# Jake Grycel
#
# (c) 2022 The MITRE Corporation
#
# This source file is part of an example system for MITRE's 2022 Embedded System
# CTF (eCTF). This code is being provided only for educational purposes for the
# 2022 MITRE eCTF competition, and may not meet MITRE standards for quality.
# Use this code at your own risk!

import argparse
import socket
import time
import os


def parse_args():
    parser = argparse.ArgumentParser(description="Emulated bootloader reset tool")

    parser.add_argument(
        "--restart-sock",
        help="Path to the local folder where the device sockets are located",
        required=True,
    )
    return parser.parse_args()


def main():
    args = parse_args()

    # Construct the socket and release message file paths
    restart_sfile = os.path.join(args.restart_sock)

    print("Restarting the bootloader...")

    # Send character over UART to trigger interrupt
    with socket.socket(socket.AF_UNIX, socket.SOCK_STREAM) as sock:
        sock.connect(restart_sfile)
        sock.send(b"E")
    time.sleep(2)
    print("Restarted bootloader...")


if __name__ == "__main__":
    main()
 719  tools/run_saffire.py 
@@ -0,0 +1,719 @@
#!/bin/python3

# 2022 eCTF
# SAFFIRe Run Interface
# Jake Grycel
#
# (c) 2022 The MITRE Corporation
#
# This source file is part of an example system for MITRE's 2022 Embedded System
# CTF (eCTF). This code is being provided only for educational purposes for the
# 2022 MITRE eCTF competition, and may not meet MITRE standards for quality.
# Use this code at your own risk!
#
# DO NOT CHANGE THIS FILE

import time
import argparse
import logging
import os
from pathlib import Path
import subprocess


logging.basicConfig(
    level=logging.INFO, format="%(asctime)s:%(name)-12s%(levelname)-8s %(message)s"
)
log = logging.getLogger(Path(__file__).name)


def make_dirs(dir_list):
    for path in dir_list:
        Path(path).mkdir(exist_ok=True)


def clear_dir(d):
    p = Path(d)
    if p.exists():
        for item in Path(d).iterdir():
            if item.is_dir():
                Path.rmdir(item)
            else:
                Path.unlink(item)


def get_volume(sysname, volume):
    return f"{sysname}-{volume}.vol"


def kill_system(args):
    # Stop running bootloader containers
    cmd = ["docker", "ps", "-q", "--filter", f"ancestor={args.sysname}/bootloader"]
    bl_container_ids = (
        subprocess.run(cmd, capture_output=True).stdout.decode("latin-1").rstrip()
    )
    if bl_container_ids != "":
        for cid in bl_container_ids.split("\n"):
            cmd = ["docker", "kill", f"{cid}"]
            subprocess.run(cmd)

    # Remove stopped bootloader containers
    cmd = [
        "docker",
        "ps",
        "-a",
        "-q",
        "--filter",
        f"ancestor={args.sysname}/bootloader",
    ]
    bl_container_ids = (
        subprocess.run(cmd, capture_output=True).stdout.decode("latin-1").rstrip()
    )
    if bl_container_ids != "":
        for cid in bl_container_ids.split("\n"):
            cmd = ["docker", "rm", f"{cid}"]
            subprocess.run(cmd)

    # Stop running host_tools containers
    cmd = ["docker", "ps", "-q", "--filter", f"ancestor={args.sysname}/host_tools"]
    host_container_ids = (
        subprocess.run(cmd, capture_output=True).stdout.decode("latin-1").rstrip()
    )
    if host_container_ids != "":
        for cid in host_container_ids.split("\n"):
            cmd = ["docker", "kill", f"{cid}"]
            subprocess.run(cmd)

    # Remove stopped host_tools containers
    cmd = [
        "docker",
        "ps",
        "-a",
        "-q",
        "--filter",
        f"ancestor={args.sysname}/host_tools",
    ]
    host_container_ids = (
        subprocess.run(cmd, capture_output=True).stdout.decode("latin-1").rstrip()
    )
    if host_container_ids != "":
        for cid in host_container_ids.split("\n"):
            cmd = ["docker", "rm", f"{cid}"]
            subprocess.run(cmd)


def build_system(args):

    # Check for type
    if args.physical:
        log.info("build_system: Physical systems not supported yet")
        exit(0)
    elif args.emulated:
        parent = "ectf/ectf-qemu:tiva"
    else:
        exit("build_system: Missing '--emulated' or '--physical'")

    # Get Docker-managed volumes
    secrets_root = get_volume(args.sysname, "secrets")

    # Remove the old secrets
    cmd = ["docker", "volume", "rm", f"{secrets_root}"]
    subprocess.run(cmd)

    # Build host tools
    cmd = [
        "docker",
        "build",
        ".",
        "-f",
        "dockerfiles/1_build_saffire.Dockerfile",
        "-t",
        f"{args.sysname}/host_tools",
        "--build-arg",
        f"OLDEST_VERSION={args.oldest_allowed_version}",
    ]
    subprocess.run(cmd)

    # Build device
    cmd = [
        "docker",
        "build",
        ".",
        "-f",
        "dockerfiles/2_create_device.Dockerfile",
        "-t",
        f"{args.sysname}/bootloader",
        "--build-arg",
        f"SYSNAME={args.sysname}",
        "--build-arg",
        f"PARENT={parent}",
    ]
    subprocess.run(cmd)


def clear_device_state(args):
    # Get Docker-managed volumes
    flash_root = get_volume(args.sysname, "flash")
    eeprom_root = get_volume(args.sysname, "eeprom")

    # Clear the Flash and EEPROM volumes so that new container has fresh state
    cmd = ["docker", "volume", "rm", f"{flash_root}"]
    subprocess.run(cmd)

    cmd = ["docker", "volume", "rm", f"{eeprom_root}"]
    subprocess.run(cmd)


def load_device(args):

    # Check for type
    if args.emulated:
        clear_device_state(args)
    elif args.physical:
        if args.serial_port is None:
            log.error("load_device: Missing '--serial-port' for physical flow")
            exit(1)
        log.info("load_device: Physical systems not supported yet")
        exit(0)
    else:
        log.error("load_device: Missing '--emulated' or '--physical'")
        exit(1)
    log.info('Loaded device')


def launch_emulator(args, interactive=False, do_gdb=False):

    # Need abspath for local folder to mount as a Docker volume
    sock_root = os.path.abspath(args.sock_root)
    make_dirs([sock_root])

    # Get Docker-managed volumes
    flash_root = get_volume(args.sysname, "flash")
    eeprom_root = get_volume(args.sysname, "eeprom")

    gdb_arg = ""
    if do_gdb:
        gdb_arg = "--gdb"

    if interactive:
        dock_opt = "-i"
    else:
        dock_opt = "-d"

    cmd = [
        "docker",
        "run",
        f"{dock_opt}",
        "--network",
        "host",
        "-v",
        f"{sock_root}:/external_socks",
        "-v",
        f"{flash_root}:/flash",
        "-v",
        f"{eeprom_root}:/eeprom",
        f"{args.sysname}/bootloader",
        "sh",
        "/platform/launch_platform.sh",
        "--uart_sock",
        f"{args.uart_sock}",
        f"{gdb_arg}",
    ]
    subprocess.run(cmd)

    if do_gdb:
        cmd = ["docker", "create", f"{args.sysname}/bootloader"]
        container_id = (
            subprocess.run(cmd, capture_output=True).stdout.decode("latin-1").rstrip()
        )

        cmd = [
            "docker",
            "cp",
            f"{container_id}:bootloader/bootloader.elf",
            f"{args.sysname}-bootloader.elf.deleteme",
        ]
        subprocess.run(cmd)

        cmd = ["docker", "rm", "-v", f"{container_id}"]
        subprocess.run(cmd)

        # Wait for a few seconds before connecting
        time.sleep(3)
        cmd = [
            "docker",
            "run",
            "-v",
            f"{sock_root}:/external_socks",
            f"{args.sysname}/bootloader",
            "chmod",
            "777",
            "/external_socks/gdb.sock",
        ]
        subprocess.run(cmd)

        print(
            "Launched bootloader with GDB.\n"
            "Run the following to attach to the GDB socket:\n"
            f"gdb-multiarch {args.sysname}-bootloader.elf.deleteme"
            f" -ex 'target remote {args.sock_root}/gdb.sock'"
        )


def launch_bootloader(args):
    # Check for type
    if args.emulated:
        if args.sock_root is None:
            log.error("launch_bootloader: Missing '--sock-root' for emulated flow")
            exit(1)
        launch_emulator(args)
    elif args.physical:
        if args.serial_port is None:
            log.error("launch_bootloader: Missing '--serial-port' for physical flow")
            exit(1)
        log.info("launch_bootloader: Physical systems not supported yet")
        exit(0)
    else:
        log.error("launch_bootloader: Missing '--emulated' or '--physical'")
        exit(1)


def launch_bootloader_gdb(args):
    if args.sock_root is None:
        log.error("launch_bootloader_gdb: Missing '--sock-root' for emulated flow")
        exit(1)
    launch_emulator(args, do_gdb=True)


def launch_bootloader_interactive(args):
    if args.sock_root is None:
        log.error(
            "launch_bootloader_interactive: Missing '--sock-root' for emulated flow"
        )
        exit(1)
    launch_emulator(args, interactive=True)


def fw_protect(args):
    # Get Docker-managed volumes
    secrets_root = get_volume(args.sysname, "secrets")

    # Need abspath for local folder to mount as a Docker volume
    fw_root = os.path.abspath(args.fw_root)
    make_dirs([fw_root])

    cmd = [
        "docker",
        "run",
        "-i",
        "-v",
        f"{secrets_root}:/secrets",
        "-v",
        f"{fw_root}:/firmware",
        f"{args.sysname}/host_tools",
        "/host_tools/fw_protect",
        "--firmware",
        f"{args.raw_fw_file}",
        "--version",
        f"{args.fw_version}",
        "--release-message",
        f"{args.fw_message}",
        "--output-file",
        f"{args.protected_fw_file}",
    ]
    subprocess.run(cmd)


def cfg_protect(args):
    # Get Docker-managed volumes
    secrets_root = get_volume(args.sysname, "secrets")

    # Need abspath for local folder to mount as a Docker volume
    cfg_root = os.path.abspath(args.cfg_root)
    make_dirs([cfg_root])

    cmd = [
        "docker",
        "run",
        "-i",
        "-v",
        f"{secrets_root}:/secrets",
        "-v",
        f"{cfg_root}:/configuration",
        f"{args.sysname}/host_tools",
        "/host_tools/cfg_protect",
        "--input-file",
        f"{args.raw_cfg_file}",
        "--output-file",
        f"{args.protected_cfg_file}",
    ]
    subprocess.run(cmd)


def fw_update(args):
    # Need abspath for local folder to mount as a Docker volume
    fw_root = os.path.abspath(args.fw_root)

    make_dirs([fw_root])

    cmd = [
        "docker",
        "run",
        "-i",
        "--network",
        "host",
        "-v",
        f"{fw_root}:/firmware",
        f"{args.sysname}/host_tools",
        "/bin/bash",
        "-c",
        f"rm -rf /secrets; "
        f"/host_tools/fw_update "
        f"--socket {args.uart_sock} "
        f"--firmware-file {args.protected_fw_file}",
    ]
    subprocess.run(cmd)


def cfg_load(args):
    # Need abspath for local folder to mount as a Docker volume
    cfg_root = os.path.abspath(args.cfg_root)

    make_dirs([cfg_root])

    cmd = [
        "docker",
        "run",
        "-i",
        "--network",
        "host",
        "-v",
        f"{cfg_root}:/configuration",
        f"{args.sysname}/host_tools",
        "/bin/bash",
        "-c",
        f"rm -rf /secrets ; "
        f"/host_tools/cfg_load "
        f"--socket {args.uart_sock} "
        f"--config-file {args.protected_cfg_file}",
    ]
    subprocess.run(cmd)


def readback(args, rb_region):
    # Get Docker-managed volumes
    secrets_root = get_volume(args.sysname, "secrets")

    cmd = [
        "docker",
        "run",
        "-i",
        "--network",
        "host",
        "-v",
        f"{secrets_root}:/secrets",
        f"{args.sysname}/host_tools",
        "/host_tools/readback",
        "--socket",
        f"{args.uart_sock}",
        "--region",
        f"{rb_region}",
        "--num-bytes",
        f"{args.rb_len}",
    ]
    subprocess.run(cmd)


def fw_readback(args):
    readback(args, rb_region="firmware")


def cfg_readback(args):
    readback(args, rb_region="configuration")


def boot(args):
    # Get Docker-managed volumes
    msg_root = get_volume(args.sysname, "messages")

    cmd = [
        "docker",
        "run",
        "-i",
        "--network",
        "host",
        "-v",
        f"{msg_root}:/messages",
        f"{args.sysname}/host_tools",
        "/bin/bash",
        "-c",
        f"rm -rf /secrets; "
        f"/host_tools/boot "
        f"--socket {args.uart_sock} "
        f"--release-message-file {args.boot_msg_file}",
    ]
    subprocess.run(cmd)


def monitor(args):
    # Get Docker-managed volumes
    msg_root = get_volume(args.sysname, "messages")

    cmd = [
        "docker",
        "run",
        "-i",
        "--network",
        "host",
        "-v",
        f"{msg_root}:/messages",
        f"{args.sysname}/host_tools",
        "/bin/bash",
        "-c",
        f"rm -rf /secrets ; "
        f"/host_tools/monitor "
        f"--socket {args.uart_sock} "
        f"--release-message-file {args.boot_msg_file}",
    ]
    subprocess.run(cmd)


def get_args():
    parser = argparse.ArgumentParser(fromfile_prefix_chars="@")
    subparsers = parser.add_subparsers(dest='cmd', help="sub-command help")
    subparsers.required = True

    parser_kill = subparsers.add_parser("kill-system", help="kill-system help")
    parser_kill.add_argument("--sysname", required=True, help="SAFFIRe system name")
    parser_kill.set_defaults(func=kill_system)

    # Build SAFFIRe
    parser_create = subparsers.add_parser("build-system", help="build-system help")
    parser_create.add_argument(
        "--sysname",
        required=True,
        help="SAFFIRe system name",
    )
    parser_create.add_argument(
        "--oldest-allowed-version",
        required=True,
        help="Oldest allowed firmware version on device",
    )
    create_group = parser_create.add_mutually_exclusive_group(required=True)
    create_group.add_argument(
        "--physical",
        action="store_true",
        help="Run system for physical device",
    )
    create_group.add_argument(
        "--emulated",
        action="store_true",
        help="Run system for emulated device",
    )
    parser_create.set_defaults(func=build_system)

    # Load device with newest SAFFIRe bootloader
    parser_load = subparsers.add_parser("load-device", help="load-device help")
    parser_load.add_argument("--sysname", required=True, help="SAFFIRe system name")
    parser_load.add_argument(
        "--serial-port", default=None, help="Physical device serial port"
    )
    load_group = parser_load.add_mutually_exclusive_group(required=True)
    load_group.add_argument(
        "--physical",
        action="store_true",
        help="Run system for physical device",
    )
    load_group.add_argument(
        "--emulated",
        action="store_true",
        help="Run system for emulated device",
    )
    parser_load.set_defaults(func=load_device)

    # Run bootloader
    parser_bl = subparsers.add_parser(
        "launch-bootloader", help="launch-bootloader help"
    )
    parser_bl.add_argument("--sysname", required=True, help="SAFFIRe system name")
    parser_bl.add_argument("--sock-root", help="Directory to place sockets")
    parser_bl.add_argument("--uart-sock", required=True, help="UART interface socket")
    parser_bl.add_argument("--serial-port", help="Physical device serial port")
    bl_group = parser_bl.add_mutually_exclusive_group(required=True)
    bl_group.add_argument(
        "--physical",
        action="store_true",
        help="Run system for physical device",
    )
    bl_group.add_argument(
        "--emulated",
        action="store_true",
        help="Run system for emulated device",
    )
    parser_bl.set_defaults(func=launch_bootloader)

    # Run bootloader in interactive mode (emulated only)
    parser_bl_i = subparsers.add_parser(
        "launch-bootloader-interactive", help="launch-bootloader-interactive help"
    )
    parser_bl_i.add_argument("--sysname", required=True, help="SAFFIRe system name")
    parser_bl_i.add_argument(
        "--sock-root", required=True, help="Directory to place sockets"
    )
    parser_bl_i.add_argument("--uart-sock", required=True, help="UART interface socket")
    parser_bl_i.set_defaults(func=launch_bootloader_interactive)

    # Run bootloader with GDB (emulated only)
    parser_bl_gdb = subparsers.add_parser(
        "launch-bootloader-gdb", help="launch-bootloader-gdb help"
    )
    parser_bl_gdb.add_argument("--sysname", required=True, help="SAFFIRe system name")
    parser_bl_gdb.add_argument(
        "--sock-root", required=True, help="Directory to place sockets"
    )
    parser_bl_gdb.add_argument(
        "--uart-sock", required=True, help="UART interface socket"
    )
    parser_bl_gdb.set_defaults(func=launch_bootloader_gdb)

    # Firmware protect
    parser_fw_protect = subparsers.add_parser("fw-protect", help="fw-protect help")
    parser_fw_protect.add_argument(
        "--sysname", required=True, help="SAFFIRe system name"
    )
    parser_fw_protect.add_argument(
        "--fw-root", required=True, help="Directory to read and save firmware images"
    )
    parser_fw_protect.add_argument(
        "--raw-fw-file", required=True, help="Firmware protect input file"
    )
    parser_fw_protect.add_argument(
        "--protected-fw-file", required=True, help="Firmware protect output file"
    )
    parser_fw_protect.add_argument(
        "--fw-version", required=True, help="Firmware protect version"
    )
    parser_fw_protect.add_argument(
        "--fw-message", required=True, help="Firmware protect release message"
    )
    parser_fw_protect.set_defaults(func=fw_protect)

    # Configuration protect
    parser_cfg_protect = subparsers.add_parser("cfg-protect", help="cfg-protect help")
    parser_cfg_protect.add_argument(
        "--sysname", required=True, help="SAFFIRe system name"
    )
    parser_cfg_protect.add_argument(
        "--cfg-root",
        required=True,
        help="Directory to read and save configuration images",
    )
    parser_cfg_protect.add_argument(
        "--raw-cfg-file", required=True, help="Configuration protect input file"
    )
    parser_cfg_protect.add_argument(
        "--protected-cfg-file", required=True, help="Configuration protect output file"
    )
    parser_cfg_protect.set_defaults(func=cfg_protect)

    # Firmware update
    parser_fw_update = subparsers.add_parser("fw-update", help="fw-update help")
    parser_fw_update.add_argument(
        "--sysname", required=True, help="SAFFIRe system name"
    )
    parser_fw_update.add_argument(
        "--fw-root", required=True, help="Directory to read firmware images"
    )
    parser_fw_update.add_argument(
        "--uart-sock", required=True, help="UART interface socket"
    )
    parser_fw_update.add_argument(
        "--protected-fw-file", required=True, help="Firmware update input file"
    )
    parser_fw_update.set_defaults(func=fw_update)

    # Load configuration
    parser_cfg_load = subparsers.add_parser("cfg-load", help="cfg-load help")
    parser_cfg_load.add_argument("--sysname", required=True, help="SAFFIRe system name")
    parser_cfg_load.add_argument(
        "--cfg-root", required=True, help="Directory to read configuration images"
    )
    parser_cfg_load.add_argument(
        "--uart-sock", required=True, help="UART interface socket"
    )
    parser_cfg_load.add_argument(
        "--protected-cfg-file", required=True, help="Configuration load input file"
    )
    parser_cfg_load.set_defaults(func=cfg_load)

    # Firmware readback
    parser_fw_readback = subparsers.add_parser("fw-readback", help="fw-readback help")
    parser_fw_readback.add_argument(
        "--sysname", required=True, help="SAFFIRe system name"
    )
    parser_fw_readback.add_argument(
        "--uart-sock", required=True, help="UART interface socket"
    )
    parser_fw_readback.add_argument(
        "--rb-len", required=True, help="Readback request data length"
    )
    parser_fw_readback.set_defaults(func=fw_readback)

    # Configuration readback
    parser_cfg_readback = subparsers.add_parser(
        "cfg-readback", help="cfg-readback help"
    )
    parser_cfg_readback.add_argument(
        "--sysname", required=True, help="SAFFIRe system name"
    )
    parser_cfg_readback.add_argument(
        "--uart-sock", required=True, help="UART interface socket"
    )
    parser_cfg_readback.add_argument(
        "--rb-len", required=True, help="Readback request data length"
    )
    parser_cfg_readback.set_defaults(func=cfg_readback)

    # Device boot
    parser_boot = subparsers.add_parser("boot", help="boot help")
    parser_boot.add_argument("--sysname", required=True, help="SAFFIRe system name")
    parser_boot.add_argument("--uart-sock", required=True, help="UART interface socket")
    parser_boot.add_argument(
        "--boot-msg-file",
        required=True,
        help="File path for host to store booted release message in",
    )
    parser_boot.set_defaults(func=boot)

    # Firmware monitor
    parser_monitor = subparsers.add_parser("monitor", help="monitor help")
    parser_monitor.add_argument("--sysname", required=True, help="SAFFIRe system name")
    parser_monitor.add_argument(
        "--uart-sock", required=True, help="UART interface socket"
    )
    parser_monitor.add_argument(
        "--boot-msg-file",
        required=True,
        help="File path for host to read booted release messages from",
    )
    parser_monitor.set_defaults(func=monitor)

    args, unknown = parser.parse_known_args()

    return args


def main():
    # Check that we are running from the root of the repo
    exec_dir = Path().resolve()
    expected_git_path = exec_dir / ".git"
    if not expected_git_path.exists():
        exit("ERROR: This script must be run from the root of the repo!")

    # Get args and call specified function
    args = get_args()
    args.func(args)


if __name__ == "__main__":
    main()
